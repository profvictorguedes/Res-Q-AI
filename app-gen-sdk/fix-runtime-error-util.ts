/* eslint-disable @typescript-eslint/no-unsafe-return */
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { getRpcClient } from './rpc-client';

export interface IFixRuntimeError {
    message: string;
    errorStack: string;
    componentStack: string;
}

function getIframeBaseUrl(): string {
    // Try to get the base URL from various sources
    if (window.location.origin) {
        return window.location.origin;
    }

    // Fallback: construct from protocol + host
    return `${window.location.protocol}//${window.location.host}`;
}

function cleanStackTrace(stackTrace: string): string {
    const baseUrl = getIframeBaseUrl();

    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any
    return (stackTrace as any)
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        .replaceAll(baseUrl, '')
        // Remove Vite version parameters (?v=...) and timestamp parameters (?t=...)
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        .replace(/\?[vt]=[a-zA-Z0-9]+/g, '')
        // Remove any remaining query parameters that might clutter the stack trace
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        .replace(/\?[^)\s]+/g, '');
}

function createSafeXml(errorInfo: IFixRuntimeError): string {
    const doc = document.implementation.createDocument(null, 'error', null);
    const root = doc.documentElement;

    const createElement = (tagName: string, textContent: string): HTMLElement => {
        const element = doc.createElement(tagName);
        element.textContent = textContent;
        root.appendChild(element);
        return element;
    };

    createElement('message', errorInfo.message);

    if (errorInfo.componentStack) {
        createElement('componentStack', cleanStackTrace(errorInfo.componentStack));
    }

    if (errorInfo.errorStack) {
        createElement('errorStack', cleanStackTrace(errorInfo.errorStack));
    }

    const serializer = new XMLSerializer();
    return '<?xml version="1.0" encoding="UTF-8"?>' + serializer.serializeToString(doc);
}

async function fetchCompilationError(url: string): Promise<{ message: string; stack: string } | null> {
    try {
        const response = await fetch(url);
        const html = await response.text();

        // Extract the error object from the script tag
        const scriptMatch = html.match(/const error = ({.*?});/s);
        if (!scriptMatch) {
            return null;
        }

        // Return the first 50 lines of the message
        const messageLines = scriptMatch[1].split('\\n');
        const topLines = messageLines.slice(0, 50).join('\n');

        return {
            message: topLines,
            stack: ''
        };
    } catch (error) {
        console.error('Failed to fetch compilation error:', error);
        return null;
    }
}

export async function fixRuntimeError(options: IFixRuntimeError): Promise<void> {
    let errorInfo = { ...options };

    // Check if this is a dynamic import failure error
    if (options.message.includes('Failed to fetch dynamically imported module:')) {
        const urlMatch = options.message.match(/Failed to fetch dynamically imported module: (https?:\/\/[^\s]+)/);
        if (urlMatch) {
            const failedUrl = urlMatch[1];
            const compilationError = await fetchCompilationError(failedUrl);

            if (compilationError) {
                // Update the error info with the actual compilation error
                errorInfo = {
                    message: compilationError.message,
                    errorStack: '',
                    componentStack: '',
                };
            }
        }
    }

    const errorXml = createSafeXml(errorInfo);

    const fnOptions = {
        errorXml
    };

    await getRpcClient().call('fixRuntimeErrorAsync', [fnOptions]);
}

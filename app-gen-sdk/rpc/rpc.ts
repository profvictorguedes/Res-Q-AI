/* eslint-disable eslint-comments/no-restricted-disable */
/* eslint-disable */

/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { v4 as uuid } from 'uuid';
import { convertToException, RpcException } from './exception';


export type RpcMessageListenerCallback = (rpcMessage: RpcMessage) => void;

const PING = '__PING__';
const PONG = '__PONG__';

export interface RpcMessage {
  signature: string; // signature number
  additionalData?: any;
  id: string;
}

export interface RpcRequestMessage extends RpcMessage {
  method: string;
  params: any[];
}

export interface RpcResponseMessage extends RpcMessage {
  result?: any;
  error?: any;
}

export interface RpcLogger {
  logResponseMessageReceived(rpcMessage: RpcMessage): void;
  logRequestMessageReceived(rpcMessage: RpcMessage): void;
  logMessageSent(rpcMessage: RpcMessage): void;
}

export interface RpcMessageHandler {
  postMessage(rpcMessage: RpcMessage, targetOrigin: string): void;

  addListener(listener: RpcMessageListenerCallback): void;
  removeListener(listener: RpcMessageListenerCallback): void;
}

export interface RpcOptions {
  signature: string;
  // Can be used to pass additional data such
  // as the session id on the RPC messages.
  additionalData?: any;
  targetOrigin: string;
  rpcMessageHandler: RpcMessageHandler;
  rpcLogger?: RpcLogger;

  // if not set will use ES6-Promises.
  Promise?: {
    defer(): any;
    resolve(value: any): any;
    reject(value: any): any;
  };
}

interface RpcOptionsInternal {
  signature: string;
  additionalData?: any;
  targetOrigin: string;
  rpcMessageHandler: RpcMessageHandler;
  rpcLogger?: RpcLogger;

  // if not set will use ES6-Promises.
  Promise: {
    defer(): any;
    resolve(value: any): any;
    reject(value: any): any;
  };
}

interface SerializedError {
  error: boolean;
  value: any;
}

function defer<T>(): Deferred<T> {
  const deferred: Deferred<T> = {} as any;
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });

  return deferred;
}

interface Deferred<T> {
  promise: Promise<T>;
  resolve(value: T): void;
  reject(error: any): void;
}

export class Rpc {
  private _rpcOptions: RpcOptionsInternal;
  private _deferredResponses: Record<string, Deferred<any>> = {};
  private _rpcMethods: Record<string, Function> = {};

  private _ready = false;
  private _queuedRequestMessages: RpcRequestMessage[] = [];

  constructor(rpcOptions: RpcOptions) {
    if (!rpcOptions) {
      throw new Error('rpcOptions required');
    }

    this._rpcOptions = {
      Promise: {
        defer,
        resolve: (value: any) => Promise.resolve(value),
        reject: (value: any) => Promise.reject(value),
      },
      ...rpcOptions,
    };
    this._rpcOptions.rpcMessageHandler.addListener(this._onRpcMessageReceived);

    this.register(PING, this._onPing);
  }

  public async ack(): Promise<any> {
    // only iframe (child) calls this method

    // unregister ping since we are not the shell
    this.unregister(PING);

    try {
      const message = await this.call<string>(PING);
      if (message === PONG) {
        // shell notified that the shell is ready
        this._ready = true;
        this._processQueue();
      } else {
        throw new Error(`Invalid PONG message ${message}`);
      }
    } catch (ex) {
      // ping failed
      this.register(PING, this._onPing);
      console.error('PING failed to receive PONG message', ex);
      throw ex;
    }
  }

  public call<T>(method: string, params?: any[]): Promise<T> {
    const id: string = uuid();
    const rpcRequestMessage = {
      signature: this._rpcOptions.signature,
      additionalData: this._rpcOptions.additionalData,
      id,
      method: this._normalizeMethodName(method),
      params,
    } as RpcRequestMessage;

    const deferred = this._rpcOptions.Promise.defer();
    this._deferredResponses[id] = deferred;

    if (this._ready || method === PING) {
      this._call(rpcRequestMessage);
    } else {
      this._queuedRequestMessages.push(rpcRequestMessage);
    }

    return deferred.promise;
  }

  public register(method: string, func: (...params: Array<any>) => void): void {
    const normalizedMethod = this._normalizeMethodName(method);
    if (this._rpcMethods[normalizedMethod]) {
      throw new Error(`Rpc method with name '${method}' already registered.`);
    }

    this._rpcMethods[normalizedMethod] = func;
  }

  public unregister(method: string) {
    const normalizedMethod = this._normalizeMethodName(method);
    if (!this._rpcMethods[normalizedMethod]) {
      throw new Error(`Rpc method with name ${method} failed to unregister. Method not found`);
    }
    delete this._rpcMethods[normalizedMethod];
  }

  public dispose(): void {
    this._rpcMethods = {};

    for (const key of Object.keys(this._deferredResponses)) {
      this._deferredResponses[key].reject(new Error('rpc disposed'));
    }

    this._deferredResponses = {};
    this._rpcOptions.rpcMessageHandler.removeListener(this._onRpcMessageReceived);
  }

  private _call(rpcRequestMessage: RpcRequestMessage): void {
    try {
      if (this._rpcOptions.rpcLogger) {
        this._rpcOptions.rpcLogger.logMessageSent(rpcRequestMessage);
      }
      this._rpcOptions.rpcMessageHandler.postMessage(rpcRequestMessage, this._rpcOptions.targetOrigin);
    } catch (ex) {
      this._deferredResponses[rpcRequestMessage.id].reject(ex);
      delete this._deferredResponses[rpcRequestMessage.id];
    }
  }

  private _onPing(): string {
    // iframe notified the shell that iframe is ready
    this.unregister(PING);
    this._ready = true;
    this._processQueue();
    return PONG;
  }

  private _processQueue() {
    for (const rpcRequestMessage of this._queuedRequestMessages) {
      this._call(rpcRequestMessage);
    }

    this._queuedRequestMessages = [];
  }

  private _normalizeMethodName(method: string): string {
    return method.toUpperCase();
  }

  private _onRpcMessageReceived = (message: RpcRequestMessage | RpcResponseMessage) => {
    if (!message || message.signature !== this._rpcOptions.signature) {
      return;
    }

    const rpcRequestMessage = message as RpcRequestMessage;
    if (rpcRequestMessage.method) {
      this._onRpcRequestMessageReceived(rpcRequestMessage);
    } else {
      this._onRpcResponseMessageReceived(message as RpcResponseMessage);
    }
  };

  private _onRpcRequestMessageReceived = (rpcRequestMessage: RpcRequestMessage) => {
    const rpcMethod = this._rpcMethods[rpcRequestMessage.method];
    if (!rpcMethod) {
      return;
    }

    const rpcResponseMessage = {
      signature: rpcRequestMessage.signature,
      additionalData: rpcRequestMessage.additionalData,
      id: rpcRequestMessage.id,
      error: null,
    } as RpcResponseMessage;

    try {
      const result = rpcMethod.apply(this, rpcRequestMessage.params);
      // NOTE: rather then checking if result is a Promise or not,
      // always use Promise.resolve(result) so that if the result is a Promise,
      // 'then/catch callback' will only be called after the result promise is completed.
      this._rpcOptions.Promise.resolve(result)
        .then((result2: any) => {
          if (this._rpcOptions.rpcLogger) {
            this._rpcOptions.rpcLogger.logRequestMessageReceived(rpcResponseMessage);
          }

          rpcResponseMessage.result = result2;
          this._rpcOptions.rpcMessageHandler.postMessage(rpcResponseMessage, this._rpcOptions.targetOrigin);
        })
        .catch((ex: any) => {
          rpcResponseMessage.error = this._serializeError(ex);

          if (this._rpcOptions.rpcLogger) {
            this._rpcOptions.rpcLogger.logRequestMessageReceived(rpcResponseMessage);
          }
          this._rpcOptions.rpcMessageHandler.postMessage(rpcResponseMessage, this._rpcOptions.targetOrigin);
        });
    } catch (ex) {
      // propagate the error correctly to the caller incase there was a synchronous error thrown by the rpcMethod implementation
      rpcResponseMessage.error = this._serializeError(ex);

      if (this._rpcOptions.rpcLogger) {
        this._rpcOptions.rpcLogger.logRequestMessageReceived(rpcResponseMessage);
      }
      this._rpcOptions.rpcMessageHandler.postMessage(rpcResponseMessage, this._rpcOptions.targetOrigin);
    }
  };

  private _onRpcResponseMessageReceived = (rpcResponseMessage: RpcResponseMessage) => {
    const deferred = this._deferredResponses[rpcResponseMessage.id];
    if (deferred) {
      if (this._rpcOptions.rpcLogger) {
        this._rpcOptions.rpcLogger.logResponseMessageReceived({
          ...rpcResponseMessage,
          result: undefined,
        } as any);
      }
      if (rpcResponseMessage.error) {
        deferred.reject(this._deserializeError(rpcResponseMessage.error));
      } else {
        deferred.resolve(rpcResponseMessage.result);
      }
      delete this._deferredResponses[rpcResponseMessage.id];
    }
  };

  private _serializeError(ex: any): any {
    if (ex instanceof Error) {
      const value: any = {
        name: ex.name,
        message: ex.message,
        _stack: ex.stack,
      };

      for (const key of Object.keys(ex)) {
        value[key] = (ex as any)[key];
      }

      return {
        value,
      };
    } else {
      return {
        value: ex,
      };
    }
  }

  private _deserializeError(error: SerializedError): RpcException {
    return new RpcException('ReceiverFailed', 'Receiver failed', convertToException(error.value));
  }
}

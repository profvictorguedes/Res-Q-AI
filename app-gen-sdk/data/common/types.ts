/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import type { ColumnToTypescriptMapping, TableToTypescriptMapping } from './table-mapping-types';

export interface FieldMetadata {
  id: string;
  name: string;
  type: 'Text'
  | 'TextArea'
  | 'Email'
  | 'Phone'
  | 'MultipleLinesText'
  | 'Url'
  | 'StockTickerSymbol'
  | 'Currency'
  | 'Decimal'
  | 'Duration'
  | 'Float'
  | 'WholeNumber'
  | 'TimeZone'
  | 'LanguageCode'
  | 'DateAndTime'
  | 'DateOnly'
  | 'MultiChoices'
  | 'Choice'
  | 'YesNo'
  | 'UniqueId'
  | 'Lookup';
  required: boolean;
  referencedTableId?: string;
  referencedColumnId?: string;
  choices?: Array<{ name: string; value: string | number }>;
}

export interface TableMetadata {
  id: string;
  dataSourceType: 'Dataverse' | 'SharePoint' | 'InMemory';
  connectionInfo?: IConnectionInfo;
  serializedTableMetadata?: string;
  serializedInitialTableData?: string;
  displayName: string;
  fields: FieldMetadata[];
  primaryIdFieldId: string;
  primaryNameFieldId?: string;
}

export interface IConnectionInfo {
  ConnectionId: string;
  DatasetValue: string;
  TableId: string;
}

export interface TableSchemaMetadata {
  tables: TableMetadata[];
}

export type TableCell = string | number | number[] | boolean | object | null | undefined;

export type NotNullOrUndefinedTableCell = Exclude<TableCell, null | undefined>;

export type TableRow = Record<string, TableCell>;

// eslint-disable-next-line @typescript-eslint/naming-convention
export const ColumnDataType = {
    Phone: 'Phone',
    Email: 'Email',
    Url: 'Url',
    BigInt: 'BigInt',
    Integer: 'Integer',
    LanguageCode: 'LanguageCode',
    Duration: 'Duration',
    TimeZone: 'TimeZone',
    MultiLineTextArea: 'MultiLineTextArea',
    MultiLineRichTextArea: 'MultiLineRichTextArea',
    TickerSymbol: 'TickerSymbol',
    Text: 'Text',
    Uniqueidentifier: 'Uniqueidentifier',
    SingleLineTextArea: 'SingleLineTextArea',
    SingleLineRichText: 'SingleLineRichText',
    Money: 'Money',
    Decimal: 'Decimal',
    Double: 'Double',
    DateOnly: 'DateOnly',
    DateAndTime: 'DateAndTime',
    Choice: 'Choice',
    Choices: 'Choices',
    Boolean: 'Boolean',
    Lookup: 'Lookup',
    NoMatch: 'NoMatch',
} as const;
export type ColumnDataType = typeof ColumnDataType[keyof typeof ColumnDataType];

export interface GetCustomApiPropertyNameOptions {
    dataClient: IAppGenDataClient;
    column: ColumnToTypescriptMapping;
}

export interface MapApiRowToDataSourceRowCustomFormattersOptions {
    dataClient: IAppGenDataClient;
    column: ColumnToTypescriptMapping;
    row: TableRow;
    tableCell: NotNullOrUndefinedTableCell;
    tableMetadata: TableToTypescriptMapping;
}

export interface IOperationOptions {
    filter?: string;
    orderBy?: string[];
}

export interface MapApiRowToDataSourceRowOptions {
    customFormatters: Partial<Record<ColumnDataType, (
        options: MapApiRowToDataSourceRowCustomFormattersOptions,
    ) => Promise<TableCell>>>;
    getCustomApiPropertyName: Partial<Record<ColumnDataType, (options: GetCustomApiPropertyNameOptions) => string>>;
}

export interface MapDataSourceRowToTypescriptRowCustomFormattersOptions {
    dataClient: IAppGenDataClient;
    column: ColumnToTypescriptMapping;
    row: TableRow;
    tableCell: NotNullOrUndefinedTableCell;
}

export interface MapDataSourceRowToApiRowCustomFormattersOptions {
    dataClient: IAppGenDataClient;
    column: ColumnToTypescriptMapping;
    tableCell: NotNullOrUndefinedTableCell;
    tableMetadata: TableToTypescriptMapping;
}

export interface MapDataSourceRowToApiRowOptions {
    customFormatters: Partial<Record<ColumnDataType, (
        options: MapDataSourceRowToApiRowCustomFormattersOptions,
    ) => Promise<TableCell>>>;
    getCustomOutputApiPropertyName: Partial<Record<ColumnDataType, (options: GetCustomApiPropertyNameOptions) => string>>;
}

export interface ConvertRetrieveAllOptionsFromTypescriptToApiOptions {
    convertFilterAsync?: (tableMetadata: TableToTypescriptMapping, filter: string) => Promise<string>;
    convertOrderByAsync?: (tableMetadata: TableToTypescriptMapping, orderBy: string[]) => Promise<string[]>;
}

export interface IAppGenDataClient {
    createRecordAsync(tableMetadata: TableToTypescriptMapping, record: TableRow): Promise<void>;
    updateRecordAsync(tableMetadata: TableToTypescriptMapping, record: TableRow, recordId: string): Promise<void>;
    deleteRecordAsync(tableMetadata: TableToTypescriptMapping, recordId: string): Promise<void>;
    retrieveRecordAsync(tableMetadata: TableToTypescriptMapping, recordId: string): Promise<TableRow>;
    retrieveMultipleRecordsAsync(tableMetadata: TableToTypescriptMapping, options?: IOperationOptions): Promise<TableRow[]>;
    requiresFullRowForUpdate(): boolean;
}

export interface DataSourceOperations {
    /**
     * Throw if the input record is invalid.
     * @param tableMetadata The metadata for the table.
     * @param record The record to validate.
     */
    throwIfInputRecordIsInvalid(tableMetadata: TableToTypescriptMapping, record: TableRow): Promise<void>;

    /**
     * Throw if the input options are invalid.
     * @param tableMetadata The metadata for the table.
     * @param options The options to validate.
     */
    throwIfInputOptionsIsInvalid(tableMetadata: TableToTypescriptMapping, options?: IOperationOptions): Promise<void>;

    /**
     * Maps a TypeScript row to a data source row.
     * @param tableMetadata The metadata for the table.
     * @param typescriptRow The TypeScript row to map.
     * @returns The mapped data source row.
     */
    mapTypescriptRowToDataSourceRow: (tableMetadata: TableToTypescriptMapping, typescriptRow: TableRow) => Promise<TableRow>;
    /**
     * Maps a data source row to an API row.
     * @param tableMetadata The metadata for the table.
     * @param dataSourceRow The data source row to map.
     * @param rowId The id of the row being mapped.
     * @returns The mapped API row.
     */
    mapDataSourceRowToApiRow: (tableMetadata: TableToTypescriptMapping, dataSourceRow: TableRow, rowId: string) => Promise<TableRow>;
    /**
     * Maps an API row to a data source row.
     * @param tableMetadata The metadata for the table.
     * @param apiRow The API row to map.
     * @returns The mapped data source row.
     */
    // mapRowToFriendlySchema
    mapDataSourceRowToTypescriptRow: (tableMetadata: TableToTypescriptMapping, dataSourceRow: TableRow) => Promise<TableRow>;
    /**
     * Maps an API row to a data source row.
     * @param tableMetadata The metadata for the table.
     * @param apiRow The API row to map.
     * @returns The mapped data source row.
     */
    // dataverseApiToAppRuntimeFormatter
    mapApiRowToDataSourceRow: (tableMetadata: TableToTypescriptMapping, apiRow: TableRow) => Promise<TableRow>;
}

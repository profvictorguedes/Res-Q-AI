/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { convertFromDateAndTimeToIsoString, convertFromDateOnlyToIsoString, convertFromIsoStringToDateAndTime, convertFromIsoStringToDateOnly, formatAsBool, formatAsChoice, formatAsDecimal, formatAsInt, formatAsString } from './common-formatters';
import { getTableAndColumnEventData, logWarning } from './logger-client';
import { parseOrderByEntry, throwIfOrderByFormatIsInvalid } from './odata-utils';
import type { ChoiceColumnToTypescriptMapping, LookupColumnToTypescriptMapping, TableToTypescriptMapping } from './table-mapping-types';
import { getPrimaryIdApiPropertyName, getTargetTableMetadata } from './table-metadata-utils';
import type { ConvertRetrieveAllOptionsFromTypescriptToApiOptions, DataSourceOperations, IAppGenDataClient, IOperationOptions, MapApiRowToDataSourceRowOptions, MapDataSourceRowToApiRowOptions, TableRow } from './types';

export interface CommonDataSourceOperationsOptions {
    dataClient: IAppGenDataClient;
    mapApiRowToDataSourceRowOptions: MapApiRowToDataSourceRowOptions;
    mapDataSourceRowToApiRowOptions: MapDataSourceRowToApiRowOptions;
    convertRetrieveAllOptionsFromTypescriptToApiOptions: ConvertRetrieveAllOptionsFromTypescriptToApiOptions;
}

export class CommonDataSourceOperations implements DataSourceOperations {
    private dataClient: IAppGenDataClient;
    private mapApiRowToDataSourceRowOptions: MapApiRowToDataSourceRowOptions;
    private mapDataSourceRowToApiRowOptions: MapDataSourceRowToApiRowOptions;
    private convertRetrieveAllOptionsFromTypescriptToApiOptions: ConvertRetrieveAllOptionsFromTypescriptToApiOptions;

    public constructor(
        options: CommonDataSourceOperationsOptions
    ) {
        this.dataClient = options.dataClient;
        this.mapApiRowToDataSourceRowOptions = options.mapApiRowToDataSourceRowOptions;
        this.mapDataSourceRowToApiRowOptions = options.mapDataSourceRowToApiRowOptions;
        this.convertRetrieveAllOptionsFromTypescriptToApiOptions = options.convertRetrieveAllOptionsFromTypescriptToApiOptions;
    }

    public getDataClient(): IAppGenDataClient {
        return this.dataClient;
    }

    // eslint-disable-next-line complexity
    public async throwIfInputRecordIsInvalid(tableMetadata: TableToTypescriptMapping, record: TableRow): Promise<void> {
        for (const key of Object.keys(record)) {
            const columnMapping = tableMetadata.columns.find(x => x.typescriptPropertyName === key);
            if (!columnMapping) {
                throw new Error(`The input record contains an invalid property: '${key}'. The supported properties are: ${tableMetadata.columns.map(col => col.typescriptPropertyName).join(', ')}.`);
            }

            const tableCell = record[key];
            if (tableCell === null || tableCell === undefined) {
                continue;
            }

            switch (columnMapping.type) {
                case 'Lookup':
                    {
                        const lookupColumn = columnMapping as LookupColumnToTypescriptMapping;
                        const targetTableApiMetadataTableId = lookupColumn.lookupMetadata.targetTableApiMetadataTableId;
                        const targetTableMetadata = await getTargetTableMetadata({ targetTableApiMetadataTableId });

                        if (typeof tableCell !== 'object') {
                            throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be an object with the following structure: { ${targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName}: string, ${targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName}: string }.`);
                        }

                        const lookupTableCell = tableCell as Record<string, unknown>;
                        if (lookupTableCell[targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName] === undefined
                            || lookupTableCell[targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName] === null
                        ) {
                            throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be an object with the following structure: { ${targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName}: string, ${targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName}: string }.`);
                        }
                    }
                    break;
                case 'Choices':
                    {
                        if (!Array.isArray(tableCell)) {
                            throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be an array of strings.`);
                        }

                        const choiceColumnMapping = columnMapping as ChoiceColumnToTypescriptMapping;
                        for (const selectedValue of tableCell) {
                            if (typeof selectedValue !== 'string') {
                                throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be an array of strings.`);
                            }
                            const option = choiceColumnMapping.optionSetMetadata.options.find(x => x.typescriptValue === selectedValue);

                            if (!option) {
                                throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be an array with one of the following values: ${choiceColumnMapping.optionSetMetadata.options.map(x => x.typescriptValue).join(', ')}.`);
                            }
                        }
                    }
                    break;
                case 'Choice':
                    {
                        const choiceColumnMapping = columnMapping as ChoiceColumnToTypescriptMapping;
                        const option = choiceColumnMapping.optionSetMetadata.options.find(x => x.typescriptValue === tableCell);

                        if (!option) {
                            throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be one of the following values: ${choiceColumnMapping.optionSetMetadata.options.map(x => x.typescriptValue).join(', ')}.`);
                        }
                    }
                    break;
                case 'DateOnly':
                case 'DateAndTime':
                case 'Phone':
                case 'MultiLineTextArea':
                case 'MultiLineRichTextArea':
                case 'SingleLineTextArea':
                case 'SingleLineRichText':
                case 'TickerSymbol':
                case 'Text':
                case 'Email':
                case 'Url':
                    if (typeof tableCell !== 'string') {
                        throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be a string.`);
                    }
                    break;
                case 'Boolean':
                    if (typeof tableCell !== 'boolean') {
                        throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be a boolean.`);
                    }
                    break;
                case 'Double':
                case 'Decimal':
                case 'Money':
                case 'Integer':
                case 'BigInt':
                case 'Duration':
                case 'LanguageCode':
                case 'TimeZone':
                    if (typeof tableCell !== 'number') {
                        throw new Error(`The property '${key}' for the model '${tableMetadata.modelFileName}' must be a number.`);
                    }
                    break;
            }
        }
    }

    public async throwIfInputOptionsIsInvalid(tableMetadata: TableToTypescriptMapping, options?: IOperationOptions): Promise<void> {
        if (!options) {
            return;
        }

        if (options.filter) {
            if (typeof options.filter !== 'string') {
                throw new Error(`The filter option must be a string.`);
            }
        }

        if (options.orderBy) {
            if (!Array.isArray(options.orderBy)) {
                throw new Error(`The orderBy option must be an array of strings.`);
            }

            const allPossibleOrderByClauses = new Set<string>();
            for (const column of tableMetadata.columns) {
                if (column.type === 'Lookup') {
                    const lookupColumn = column as LookupColumnToTypescriptMapping;
                    const targetTableApiMetadataTableId = lookupColumn.lookupMetadata.targetTableApiMetadataTableId;
                    const targetTableMetadata = await getTargetTableMetadata({ targetTableApiMetadataTableId });
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName}`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName} asc`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName} desc`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName}`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName} asc`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}/${targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName} desc`);
                } else {
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName}`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName} asc`);
                    allPossibleOrderByClauses.add(`${column.typescriptPropertyName} desc`);
                }
            }

            for (const orderByEntry of options.orderBy) {
                if (!allPossibleOrderByClauses.has(orderByEntry)) {
                    throw new Error(`Invalid orderBy clause: ${orderByEntry}, the supported clauses are: ${Array.from(allPossibleOrderByClauses).join(', ')}.`);
                }
            }
        }
    }

    public async mapDataSourceRowToApiRow(tableMetadata: TableToTypescriptMapping, dataSourceRow: TableRow, rowId: string): Promise<TableRow> {
        const apiRow: TableRow = {};

        const primaryIdApiPropertyName = getPrimaryIdApiPropertyName(tableMetadata);

        const clonedDataSourceRow = JSON.parse(JSON.stringify(dataSourceRow)) as TableRow;
        clonedDataSourceRow[primaryIdApiPropertyName] = rowId;

        for (const column of tableMetadata.columns) {
            const cellValue = clonedDataSourceRow[column.apiPropertyName];

            let outputApiPropertyName = column.apiPropertyName;
            const customOutputApiPropertyName = this.mapDataSourceRowToApiRowOptions.getCustomOutputApiPropertyName[column.type];
            if (customOutputApiPropertyName) {
                outputApiPropertyName = customOutputApiPropertyName({ dataClient: this.dataClient, column });
            }

            if (cellValue === null) {
                apiRow[outputApiPropertyName] = cellValue;
                continue;
            } else if (cellValue === undefined) {
                continue;
            }

            const customFormatter = this.mapDataSourceRowToApiRowOptions.customFormatters[column.type];
            if (customFormatter) {
                apiRow[outputApiPropertyName] = await customFormatter({ tableMetadata, column, tableCell: cellValue, dataClient: this.dataClient });
            } else {
                switch (column.type) {
                    case 'DateOnly':
                        apiRow[outputApiPropertyName] = convertFromDateOnlyToIsoString(cellValue);
                        break;
                    case 'DateAndTime':
                        apiRow[outputApiPropertyName] = convertFromDateAndTimeToIsoString(cellValue);
                        break;
                    case 'Text':
                    case 'SingleLineRichText':
                    case 'SingleLineTextArea':
                    case 'MultiLineTextArea':
                    case 'MultiLineRichTextArea':
                    case 'Uniqueidentifier':
                    case 'Phone':
                    case 'Email':
                    case 'TickerSymbol':
                    case 'Url':
                        apiRow[outputApiPropertyName] = formatAsString(cellValue);
                        break;
                    case 'Integer':
                    case 'BigInt':
                    case 'Duration':
                    case 'LanguageCode':
                    case 'TimeZone':
                        apiRow[outputApiPropertyName] = formatAsInt(cellValue);
                        break;
                    case 'Double':
                    case 'Money':
                    case 'Decimal':
                        apiRow[outputApiPropertyName] = formatAsDecimal(cellValue);
                        break;
                    case 'Choice':
                        {
                            const choiceColumn = column as ChoiceColumnToTypescriptMapping;
                            apiRow[outputApiPropertyName] = formatAsChoice(tableMetadata, choiceColumn, cellValue);
                        }
                        break;
                    case 'Boolean':
                        apiRow[outputApiPropertyName] = formatAsBool(cellValue);
                        break;
                    default:
                        throw new Error(`Unsupported column type: ${column.type}, for table: ${tableMetadata.apiMetadataTableId}, column: ${column.apiPropertyName}`);
                }
            }
        }

        return apiRow;
    }

    public async mapTypescriptRowToDataSourceRow(tableMetadata: TableToTypescriptMapping, typescriptRow: TableRow): Promise<TableRow> {
        const dataSourceRow: TableRow = {};
        for (const typescriptKey of Object.keys(typescriptRow)) {
            const columnMapping = tableMetadata.columns.find(x => x.typescriptPropertyName === typescriptKey);
            if (!columnMapping) {
                throw new Error(`There is no property ${typescriptKey} on the model ${tableMetadata.modelFileName}`);
            }

            if (typescriptRow[typescriptKey] === null) {
                dataSourceRow[columnMapping.apiPropertyName] = typescriptRow[typescriptKey];
                continue;
            } else if (typescriptRow[typescriptKey] === undefined) {
                continue;
            }

            if (columnMapping.type === 'Lookup') {
                const lookupColumn = columnMapping as LookupColumnToTypescriptMapping;
                const targetTableApiMetadataTableId = lookupColumn.lookupMetadata.targetTableApiMetadataTableId;
                const targetTableMetadata = await getTargetTableMetadata({ targetTableApiMetadataTableId });

                const tableCell = typescriptRow[typescriptKey];
                if (typeof tableCell !== 'object') {
                    continue;
                }

                // Type-safe access to the lookup object
                const lookupObject = tableCell as Record<string, unknown>;

                dataSourceRow[columnMapping.apiPropertyName] = {
                    [targetTableMetadata.primaryIdColumnMapping.apiPropertyName]: lookupObject[targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName],
                    [targetTableMetadata.primaryNameColumnMapping.apiPropertyName]: lookupObject[targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName]
                };
            } else if (columnMapping.type === 'Choice') {
                const choiceColumn = columnMapping as ChoiceColumnToTypescriptMapping;
                const option = choiceColumn.optionSetMetadata.options.find(x => x.typescriptValue === typescriptRow[typescriptKey]);
                if (option) {
                    dataSourceRow[columnMapping.apiPropertyName] = option.apiValue;
                } else {
                    logWarning('mapTypescriptRowToDataSourceRow/Choice', {
                        type: 'UnmappedChoiceValue',
                        data: {
                            ...getTableAndColumnEventData(tableMetadata, columnMapping),
                            optionsTypescriptValues: choiceColumn.optionSetMetadata.options.map(o => o.typescriptValue),
                            typescriptOptionValue: typescriptRow[typescriptKey],
                        },
                    });
                }
            } else if (columnMapping.type === 'Choices') {
                const friendlyOptionValues: Array<string | number> = [];
                const choiceColumn = columnMapping as ChoiceColumnToTypescriptMapping;

                for (const typescriptOptionValue of typescriptRow[typescriptKey] as string[]) {
                    const option = choiceColumn.optionSetMetadata.options.find(x => x.typescriptValue === typescriptOptionValue);
                    if (option) {
                        friendlyOptionValues.push(option.apiValue);
                    } else {
                        logWarning('mapTypescriptRowToDataSourceRow/Choices', {
                            type: 'UnmappedChoiceValue',
                            data: {
                                ...getTableAndColumnEventData(tableMetadata, columnMapping),
                                optionsTypescriptValues: choiceColumn.optionSetMetadata.options.map(o => o.typescriptValue),
                                typescriptOptionValue,
                            },
                        });
                    }
                }
                dataSourceRow[columnMapping.apiPropertyName] = friendlyOptionValues;
            } else {
                dataSourceRow[columnMapping.apiPropertyName] = typescriptRow[typescriptKey];
            }
        }

        return dataSourceRow;
    }

    public async mapDataSourceRowToTypescriptRow(tableMetadata: TableToTypescriptMapping, dataSourceRow: TableRow): Promise<TableRow> {
        const typescriptRow: TableRow = {};
        for (const tableCellKey of Object.keys(dataSourceRow)) {
            const columnMapping = tableMetadata.columns.find(x => x.apiPropertyName === tableCellKey);
            if (!columnMapping) {
                throw new Error(`A column mapping could not be found for ${tableCellKey} on table ${tableMetadata.typescriptModelInterfaceName}`);
            }

            if (dataSourceRow[tableCellKey] === null) {
                typescriptRow[columnMapping.typescriptPropertyName] = dataSourceRow[tableCellKey];
                continue;
            } else if (dataSourceRow[tableCellKey] === undefined) {
                continue;
            }

            if (columnMapping.type === 'Lookup') {
                const lookupColumn = columnMapping as LookupColumnToTypescriptMapping;
                const targetTableApiMetadataTableId = lookupColumn.lookupMetadata.targetTableApiMetadataTableId;
                const targetTableMetadata = await getTargetTableMetadata({ targetTableApiMetadataTableId });

                const tableCell = dataSourceRow[tableCellKey];
                if (typeof tableCell !== 'object') {
                    continue;
                }

                // Type-safe access to the lookup object
                const lookupObject = tableCell as Record<string, unknown>;

                typescriptRow[columnMapping.typescriptPropertyName] = {
                    [targetTableMetadata.primaryIdColumnMapping.typescriptPropertyName]: lookupObject[targetTableMetadata.primaryIdColumnMapping.apiPropertyName],
                    [targetTableMetadata.primaryNameColumnMapping.typescriptPropertyName]: lookupObject[targetTableMetadata.primaryNameColumnMapping.apiPropertyName]
                };
            } else if (columnMapping.type === 'Choice') {
                const choiceColumn = columnMapping as ChoiceColumnToTypescriptMapping;
                const option = choiceColumn.optionSetMetadata.options.find(x => x.apiValue.toString() === dataSourceRow[tableCellKey]?.toString());
                if (option) {
                    typescriptRow[columnMapping.typescriptPropertyName] = option.typescriptValue;
                } else {
                    logWarning('mapDataSourceRowToTypescriptRow/Choice', {
                        type: 'UnmappedChoiceValue',
                        data: {
                            ...getTableAndColumnEventData(tableMetadata, columnMapping),
                            apiOptionValue: dataSourceRow[tableCellKey]
                        }
                    });
                }
            } else if (columnMapping.type === 'Choices') {
                const friendlyOptionValues: string[] = [];
                for (const apiOptionValue of dataSourceRow[tableCellKey] as Array<string | number>) {
                    const choiceColumn = columnMapping as ChoiceColumnToTypescriptMapping;
                    const option = choiceColumn.optionSetMetadata.options.find(x => x.apiValue.toString() === apiOptionValue?.toString());
                    if (option) {
                        friendlyOptionValues.push(option.typescriptValue);
                    } else {
                        logWarning('mapDataSourceRowToTypescriptRow/Choices', {
                            type: 'UnmappedChoiceValue',
                            data: {
                                ...getTableAndColumnEventData(tableMetadata, columnMapping),
                                optionsApiValues: choiceColumn.optionSetMetadata.options.map(o => o.apiValue),
                                apiOptionValue,
                            }
                        });
                    }
                }
                typescriptRow[columnMapping.typescriptPropertyName] = friendlyOptionValues;
            } else {
                typescriptRow[columnMapping.typescriptPropertyName] = dataSourceRow[tableCellKey];
            }
        }

        return typescriptRow;
    }

    public async mapApiRowToDataSourceRow(tableMetadata: TableToTypescriptMapping, apiRow: TableRow): Promise<TableRow> {
        const newRow: TableRow = {};

        for (const column of tableMetadata.columns) {
            const cellKey = this.mapApiRowToDataSourceRowOptions.getCustomApiPropertyName[column.type]?.({ dataClient: this.dataClient, column })
                || column.apiPropertyName;

            const cellValue = apiRow[cellKey];
            if (cellValue === null) {
                newRow[column.apiPropertyName] = cellValue;
                continue;
            } else if (cellValue === undefined) {
                continue;
            }

            const customFormatter = this.mapApiRowToDataSourceRowOptions.customFormatters[column.type];
            if (customFormatter) {
                newRow[column.apiPropertyName] = await customFormatter({ tableMetadata, dataClient: this.dataClient, column, row: apiRow, tableCell: cellValue });
            } else if (column.type === 'DateOnly') {
                newRow[column.apiPropertyName] = convertFromIsoStringToDateOnly(cellValue);
            } else if (column.type === 'DateAndTime') {
                newRow[column.apiPropertyName] = convertFromIsoStringToDateAndTime(cellValue);
            } else {
                newRow[column.apiPropertyName] = cellValue;
            }
        }

        return newRow;
    }

    public async convertOptionsToDataSourceSchema(tableMetadata: TableToTypescriptMapping, options: IOperationOptions): Promise<IOperationOptions> {
        if (!options) {
            return options;
        }

        const convertedOptions: IOperationOptions = {
            ...options
        };

        if (options.filter) {
            let convertedFilter = options.filter;

            const unsupportedDateFunctions = /\b(year|month|day|hour|minute|second|date|now)\s*\(/i;
            const match = convertedFilter.match(unsupportedDateFunctions);
            if (match) {
                throw new Error(`The ${match[1]}() OData function is not supported in filters. Please use alternative date/time filtering approaches.`);
            }

            if (this.convertRetrieveAllOptionsFromTypescriptToApiOptions.convertFilterAsync) {
                convertedFilter = await this.convertRetrieveAllOptionsFromTypescriptToApiOptions.convertFilterAsync(tableMetadata, convertedFilter);
            }

            for (const columnMapping of tableMetadata.columns) {
                // Use word boundaries to ensure we only replace whole property names
                // eslint-disable-next-line security/detect-non-literal-regexp
                const regex = new RegExp(`\\b${columnMapping.typescriptPropertyName}\\b`, 'g');
                convertedFilter = convertedFilter.replace(regex, columnMapping.apiPropertyName);
            }

            convertedOptions.filter = convertedFilter;
        }

        if (options.orderBy) {
            throwIfOrderByFormatIsInvalid(options.orderBy);

            let convertedOrderBy = options.orderBy;

            if (this.convertRetrieveAllOptionsFromTypescriptToApiOptions.convertOrderByAsync) {
                convertedOrderBy = await this.convertRetrieveAllOptionsFromTypescriptToApiOptions.convertOrderByAsync(tableMetadata, convertedOrderBy);
            }

            const newConvertedOrderBy: string[] = [];
            for (let convertedOrderByEntry of convertedOrderBy) {
                // Handle both "propertyName" and "propertyName desc" or "propertyName asc" formats
                const { propertyName, direction } = parseOrderByEntry(convertedOrderByEntry);

                const columnMapping = tableMetadata.columns.find(x => x.typescriptPropertyName === propertyName);
                if (!columnMapping) {
                    newConvertedOrderBy.push(convertedOrderByEntry);
                    continue;
                }

                convertedOrderByEntry = direction ? `${columnMapping.apiPropertyName} ${direction}` : columnMapping.apiPropertyName;
                newConvertedOrderBy.push(convertedOrderByEntry);
            }

            convertedOptions.orderBy = newConvertedOrderBy;
        }

        return convertedOptions;
    }
}

/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { getTableAndColumnEventData, logWarning } from './logger-client';
import type { ChoiceColumnToTypescriptMapping, TableToTypescriptMapping } from './table-mapping-types';
import type { NotNullOrUndefinedTableCell } from './types';

const MILLISECONDS_IN_MINUTE = 60000;

export function formatAsString(rowData: NotNullOrUndefinedTableCell): string {
    return rowData.toString();
}

export function formatAsBool(rowData: NotNullOrUndefinedTableCell): boolean {
    // Handle different input types with best effort parsing
    if (typeof rowData === 'boolean') {
        // If it's already a boolean, return as-is
        return rowData;
    }

    if (typeof rowData === 'number') {
        // Convert number to boolean: 0 is false, any other number is true
        return rowData !== 0;
    }

    // Handle string type
    const trimmed = rowData.toString().trim().toLowerCase();

    // Handle empty string
    if (trimmed === '') {
        return false;
    }

    // Handle common boolean string representations
    if (trimmed === 'true' || trimmed === 'yes' || trimmed === '1' || trimmed === 'on') {
        return true;
    }

    if (trimmed === 'false' || trimmed === 'no' || trimmed === '0' || trimmed === 'off') {
        return false;
    }

    // Try parsing as number for numeric strings
    const parsed = Number(trimmed);
    if (!Number.isNaN(parsed) && Number.isFinite(parsed)) {
        return parsed !== 0;
    }

    // If all parsing attempts fail, treat non-empty strings as true
    return true;
}

export function formatAsInt(rowData: NotNullOrUndefinedTableCell): number {
    // Handle different input types with best effort parsing
    if (typeof rowData === 'number') {
        // If it's already a number, truncate decimal part
        return Math.trunc(rowData);
    }

    if (typeof rowData === 'boolean') {
        // Convert boolean to 1 or 0
        return rowData ? 1 : 0;
    }

    // Handle string type
    const trimmed = rowData.toString().trim();

    // Handle empty string
    if (trimmed === '') {
        return 0;
    }

    // Try parsing as number first (for clean numeric strings)
    const parsed = Number(trimmed);
    if (!Number.isNaN(parsed) && Number.isFinite(parsed)) {
        return Math.trunc(parsed);
    }

    // If direct parsing fails, try to extract numbers from anywhere in the string
    // This handles cases like "$10.4", "10%", "USD 25", etc.
    const numericMatch = trimmed.match(/[-+]?d*.?d+/);
    if (numericMatch) {
        const numericPart = Number(numericMatch[0]);
        if (!Number.isNaN(numericPart) && Number.isFinite(numericPart)) {
            return Math.trunc(numericPart);
        }
    }

    // If all parsing attempts fail, return 0 as fallback
    return 0;
}

export function formatAsDecimal(rowData: NotNullOrUndefinedTableCell): number {
    // Handle different input types with best effort parsing
    if (typeof rowData === 'number') {
        // If it's already a number, return as-is (preserving decimal places)
        return Number.isFinite(rowData) ? rowData : 0;
    }

    if (typeof rowData === 'boolean') {
        // Convert boolean to 1.0 or 0.0
        return rowData ? 1.0 : 0.0;
    }

    // Handle string type
    const trimmed = rowData.toString().trim();

    // Handle empty string
    if (trimmed === '') {
        return 0.0;
    }

    // Try parsing as number first (for clean numeric strings)
    const parsed = Number(trimmed);
    if (!Number.isNaN(parsed) && Number.isFinite(parsed)) {
        return parsed;
    }

    // If direct parsing fails, try to extract numbers from anywhere in the string
    // This handles cases like "$10.4", "10.4%", "USD 10.4", etc.
    const numericMatch = trimmed.match(/[-+]?d*.?d+/);
    if (numericMatch) {
        const numericPart = Number(numericMatch[0]);
        if (!Number.isNaN(numericPart) && Number.isFinite(numericPart)) {
            return numericPart;
        }
    }

    // If all parsing attempts fail, return 0.0 as fallback
    return 0.0;
}

function isIsoDateOnlyWithoutTimeZone(value: string | undefined): boolean {
    if (typeof value !== 'string') {
        return false;
    }
    return /^\d{4}-\d{2}-\d{2}$/.test(value);
}

function parseDateFromInput(inputString: string): Date | undefined | null {
    // Don't attempt to convert integers into dates as different browsers
    // have different implementations for this, and will result on unexpected dates to the user.
    // Note: we had to use parseFloat below since parseInt  converts a string
    // like '10.24' (aka October 24th) to just '10' which will meet the below condition
    // and not try to parse the date even though we do want to support dates such as '10.24'
    if (!Number.isNaN(Number(inputString)) && Number.isInteger(parseFloat(inputString))) {
        return null;
    }

    const parsedDate = Date.parse(inputString);
    if (!Number.isNaN(parsedDate)) {
        const date = new Date(parsedDate);

        // If it is an ISO date without timezone, we need to compensate to add the timezone.
        // This is so that ISO string dates such as (ie. 2023-09-23) get parsed the same way as
        // regular string dates (ie. 09/23/2023)
        if (isIsoDateOnlyWithoutTimeZone(inputString)) {
            date.setTime(date.getTime() + date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE);
        }
        return date;
    }
    return null;
}

export function convertToIsoString(
    rowData: NotNullOrUndefinedTableCell,
    dateOnly: boolean | undefined
): string | undefined | null {
    if (rowData === '') {
        return null;
    }

    let parsedDate = parseDateFromInput(rowData.toString().trim());
    if (!parsedDate) {
        return null;
    }

    if (dateOnly) {
        parsedDate = new Date(parsedDate.getFullYear(), parsedDate.getMonth(), parsedDate.getDate());
    }

    return parsedDate.toISOString();
}

export function convertFromIsoString(
    isoString: string,
    dateOnly: boolean | undefined
): string | undefined {
    if (!isoString || typeof isoString !== 'string') {
        return undefined;
    }

    try {
        const date = new Date(isoString);

        // Check if the date is valid
        if (Number.isNaN(date.getTime())) {
            return undefined;
        }

        if (dateOnly) {
            // For date-only HTML5 inputs, return YYYY-MM-DD format
            // Adjust for timezone offset to get local date
            const localDate = new Date(date.getTime() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE);
            return localDate.toISOString().split('T')[0];
        } else {
            // For datetime-local HTML5 inputs, return YYYY-MM-DDTHH:mm format
            // Convert to local time and format for datetime-local input
            const localDate = new Date(date.getTime() - date.getTimezoneOffset() * MILLISECONDS_IN_MINUTE);
            return localDate.toISOString().slice(0, 16); // YYYY-MM-DDTHH:mm
        }
    } catch {
        return undefined;
    }
}

export function convertFromIsoStringToDateOnly(rowData: NotNullOrUndefinedTableCell): string | undefined {
    return convertFromIsoString(rowData.toString().trim(), true);
}

export function convertFromIsoStringToDateAndTime(rowData: NotNullOrUndefinedTableCell): string | undefined {
    return convertFromIsoString(rowData.toString().trim(), false);
}

export function convertFromDateAndTimeToIsoString(rowData: NotNullOrUndefinedTableCell): string | undefined | null {
    return convertToIsoString(rowData, false);
}

export function convertFromDateOnlyToIsoString(rowData: NotNullOrUndefinedTableCell): string | undefined | null {
    return convertToIsoString(rowData, true);
}

export function formatAsChoice(
    tableMetadata: TableToTypescriptMapping,
    column: ChoiceColumnToTypescriptMapping,
    tableCell: NotNullOrUndefinedTableCell
): number | undefined {
    const lowercaseTableCell = tableCell.toString().toLowerCase().trim();

    const option = column.optionSetMetadata.options.find((x) => {
        return (
            x.label.toLowerCase().trim() === lowercaseTableCell
            || x.apiValue.toString().toLowerCase().trim() === lowercaseTableCell
        );
    });

    if (option) {
        return option.apiValue as number;
    }

    logWarning('formatAsChoice', {
        type: 'UnmappedChoiceValue',
        data: {
            ...getTableAndColumnEventData(tableMetadata, column),
            invalidValue: tableCell.toString()
        }
     });

    return undefined;
}

/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { getDataModelConfig } from '../common/data-model-config-accessor';
import type { DataModelConfig, LocalData, LookupColumnToTypescriptMapping, TableToTypescriptMapping } from '../common/table-mapping-types';
import { getPrimaryIdApiPropertyName, getTargetTableMetadata } from '../common/table-metadata-utils';
import type { IAppGenDataClient, IOperationOptions, TableRow } from '../common/types';
import { extractRowId, toODataBindPropertyName } from '../dataverse/dataverse-utils';
import { createCustomFilter } from './odata-filter-utils';
import { createOrderByFn } from './odata-order-by-utils';

function throwIfInputDataIsIncorrect(newRecord: TableRow, tableMetadata: TableToTypescriptMapping): void {
    for (const columnMapping of tableMetadata.columns) {
        if (columnMapping.type === 'Choice') {
            const cellValue = newRecord[columnMapping.apiPropertyName];
            if (typeof cellValue === 'string') {
                const foundOption = columnMapping.optionSetMetadata.options
                    .find(x => x.apiValue.toString() === cellValue.toString());

                if (!foundOption) {
                    throw new Error(`Unmapped choice value: ${cellValue}, for table: ${tableMetadata.apiMetadataTableId}, column: ${columnMapping.apiPropertyName}`);
                }
            }
        } else if (columnMapping.type === 'Choices') {
            const cellValue = newRecord[columnMapping.apiPropertyName];
            if (typeof cellValue === 'string') {
                const splittedCellValues = cellValue.split(',');
                for (const splittedCellValue of splittedCellValues) {
                    const foundOption = columnMapping.optionSetMetadata.options
                        .find(x => x.apiValue.toString() === splittedCellValue.toString());
                    if (!foundOption) {
                        throw new Error(`Unmapped choice value: ${splittedCellValue}, for table: ${tableMetadata.apiMetadataTableId}, column: ${columnMapping.apiPropertyName}`);
                    }
                }
            }
        }
    }
}

export class AppGenLocalDataClient implements IAppGenDataClient {
    private localData: LocalData[] = [];
    private isInitialized: boolean = false;
    private dataModelConfig: DataModelConfig = { tableMappings: [], dataModel: { tables: [] } };

    public reset(): void {
        this.isInitialized = false;
        this.localData = [];
    }

    private ensureInitialized(): void {
        if (this.isInitialized) {
            return;
        }

        this.dataModelConfig = getDataModelConfig();
        this.localData = this.dataModelConfig.tableMappings.filter(x => x.dataSourceType === 'InMemory' && x.initialData).map(x => {
            return {
                apiMetadataTableId: x.apiMetadataTableId,
                data: x.initialData as TableRow[]
            };
        });
        this.isInitialized = true;
    }

    private getLocalDataForTable(tableMetadata: TableToTypescriptMapping): LocalData {
        this.ensureInitialized();

        const localTableData = this.localData.find(ld => ld.apiMetadataTableId === tableMetadata.apiMetadataTableId);
        if (!localTableData) {
            throw new Error(`No local data found for table: ${tableMetadata.apiMetadataTableId}`);
        }
        return localTableData;
    }

    public async createRecordAsync(tableMetadata: TableToTypescriptMapping, record: TableRow): Promise<void> {
        throwIfInputDataIsIncorrect(record, tableMetadata);

        const localTableData = this.getLocalDataForTable(tableMetadata);
        const newRecord = JSON.parse(JSON.stringify(record)) as TableRow;

        localTableData.data.push(newRecord);
        return Promise.resolve();
    }

    public async updateRecordAsync(tableMetadata: TableToTypescriptMapping, record: TableRow, recordId: string): Promise<void> {
        throwIfInputDataIsIncorrect(record, tableMetadata);

        const localTableData = this.getLocalDataForTable(tableMetadata);
        const primaryIdApiPropertyName = getPrimaryIdApiPropertyName(tableMetadata);
        const recordIndex = localTableData.data.findIndex(r => r[primaryIdApiPropertyName] === recordId);
        if (recordIndex === -1) {
            throw new Error(`Record with ID ${recordId} not found in table: ${tableMetadata.apiMetadataTableId}`);
        }
        const updatedRecord = JSON.parse(JSON.stringify({
            ...localTableData.data[recordIndex],
            ...record
        })) as TableRow;
        localTableData.data[recordIndex] = updatedRecord;

        return Promise.resolve();
    }

    public async deleteRecordAsync(tableMetadata: TableToTypescriptMapping, recordId: string): Promise<void> {
        const localTableData = this.getLocalDataForTable(tableMetadata);
        const primaryIdApiPropertyName = getPrimaryIdApiPropertyName(tableMetadata);

        for (const tableMapping of this.dataModelConfig.tableMappings) {
            for (const columnMapping of tableMapping.columns) {
                const columnAsLookup = columnMapping as LookupColumnToTypescriptMapping;

                if (columnAsLookup.type === 'Lookup' && columnAsLookup.lookupMetadata?.targetTableApiMetadataTableId === tableMetadata.apiMetadataTableId) {
                    for (const row of this.getLocalDataForTable(tableMapping).data) {
                        const value = row[toODataBindPropertyName(columnAsLookup.apiPropertyNameCaseSensitive)] as string;
                        if (value) {
                            const rowId = extractRowId(value);
                            if (rowId === recordId) {
                                throw new Error(`Cannot delete record with ID ${recordId} from table ${tableMetadata.apiMetadataTableId} because it is referenced by lookup column ${columnMapping.apiPropertyName} in table ${tableMapping.apiMetadataTableId}`);
                            }
                        }
                    }
                }
            }
        }

        const row = localTableData.data.find(r => r[primaryIdApiPropertyName] === recordId);
        if (!row) {
            throw new Error(`The row with id ${recordId} was not found in table: ${tableMetadata.apiMetadataTableId}.`);
        }

        localTableData.data = localTableData.data.filter(r => r[primaryIdApiPropertyName] !== recordId);
        return Promise.resolve();
    }

    public retrieveRecordAsync(tableMetadata: TableToTypescriptMapping, recordId: string): Promise<TableRow> {
        const localTableData = this.getLocalDataForTable(tableMetadata);
        const primaryIdApiPropertyName = getPrimaryIdApiPropertyName(tableMetadata);

        const row = localTableData.data.find(r => r[primaryIdApiPropertyName] === recordId);
        if (!row) {
            throw new Error(`The row with id ${recordId} was not found in table: ${tableMetadata.apiMetadataTableId}.`);
        }

        return Promise.resolve(row);
    }

    public async retrieveMultipleRecordsAsync(tableMetadata: TableToTypescriptMapping, options?: IOperationOptions): Promise<TableRow[]> {
        const localTableData = this.getLocalDataForTable(tableMetadata);

        // Start with a copy of the data to avoid mutating the original
        let resultData = JSON.parse(JSON.stringify(localTableData.data)) as TableRow[];
        for (const column of tableMetadata.columns) {
            if (column.type === 'Lookup') {
                const lookupColumn = column as LookupColumnToTypescriptMapping;
                const targetTableMetadata = await getTargetTableMetadata({ targetTableApiMetadataTableId: lookupColumn.lookupMetadata.targetTableApiMetadataTableId });
                const targetTableData = this.getLocalDataForTable(targetTableMetadata.targetTableMetadata);
                for (const row of resultData) {
                    const value = row[toODataBindPropertyName(lookupColumn.apiPropertyNameCaseSensitive)] as string;
                    if (value) {
                        const targetRowId = extractRowId(value);
                        const targetRow = targetTableData.data.find(x => x[targetTableMetadata.primaryIdColumnMapping.apiPropertyName] === targetRowId);
                        if (targetRow) {
                            const id = targetRow[targetTableMetadata.primaryIdColumnMapping.apiPropertyName];
                            row[`_${lookupColumn.apiPropertyName}_value`] = id;
                            const displayValue = targetRow[targetTableMetadata.primaryNameColumnMapping.apiPropertyName];
                            row[`_${lookupColumn.apiPropertyName}_formatted_value`] = displayValue;
                        }
                    }
                }
            }
        }

        // Apply filtering if provided
        const filter = options?.filter;
        if (filter) {
            try {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const filterFn = createCustomFilter(filter);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                resultData = resultData.filter(filterFn);
            } catch (error) {
                console.log(error);
                // Return original data if filter fails
                return Promise.resolve(localTableData.data);
            }
        }

        const orderBy = options?.orderBy;
        if (orderBy && orderBy.length > 0) {
            const orderByFn = createOrderByFn(orderBy);
            resultData.sort(orderByFn);
        }

        return Promise.resolve(resultData);
    }

    public requiresFullRowForUpdate(): boolean {
        return true;
    }
}

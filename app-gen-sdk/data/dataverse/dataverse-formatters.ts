/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { getTableAndColumnEventData, logWarning } from '../common/logger-client';
import type { ChoiceColumnToTypescriptMapping, LookupColumnToTypescriptMapping, TableToTypescriptMapping } from '../common/table-mapping-types';
import { getPrimaryNameColumn, getTableMetadata } from '../common/table-metadata-utils';
import type { IAppGenDataClient, NotNullOrUndefinedTableCell, TableCell, TableRow } from '../common/types';

interface MapInMemoryLookupApiCellToDataSourceCellOptions {
    column: LookupColumnToTypescriptMapping;
    tableCell: NotNullOrUndefinedTableCell;
    row: TableRow;
    dataClient: IAppGenDataClient;
}

export async function mapInMemoryLookupApiCellToDataSourceCell(options: MapInMemoryLookupApiCellToDataSourceCellOptions): Promise<TableRow | undefined> {
    const { column, tableCell, dataClient } = options;
    const inputString = tableCell.toString();

    // Extract the value between parentheses from format: /entitySetName(value)
    const match = inputString.match(/\/([^(]+)\(([^)]+)\)/);

    const entitySetName = match && match[1];
    const rowId = match && match[2];
    if (!entitySetName || !rowId) {
        return undefined;
    }

    const targetTableMetadata = await getTableMetadata({ apiDataTableId: entitySetName });

    const primaryColumnLogicalName = getPrimaryNameColumn(targetTableMetadata).apiPropertyName;
    if (!primaryColumnLogicalName) {
        return undefined;
    }

    const row = await dataClient.retrieveRecordAsync(targetTableMetadata, rowId);

    // If no match found, return the original input as lowercase and trimmed
    return {
        [`${column.lookupMetadata.targetTableApiMetadataTableId}id`]: rowId,
        [primaryColumnLogicalName]: row[primaryColumnLogicalName],
    };
}

interface MapDataverseLookupApiCellToDataSourceCellOptions {
    column: LookupColumnToTypescriptMapping;
    tableCell: NotNullOrUndefinedTableCell;
    row: TableRow;
}

export async function mapDataverseLookupApiCellToDataSourceCell(options: MapDataverseLookupApiCellToDataSourceCellOptions): Promise<TableCell | undefined> {
    const { column, row } = options;

    const targetTableLogicalName = row[`_${column.apiPropertyName}_value@Microsoft.Dynamics.CRM.lookuplogicalname`] as string;

    const targetTableMetadata = await getTableMetadata({ apiMetadataTableId: targetTableLogicalName });

    const targetTablePrimaryIdColumnLogicalName = targetTableMetadata.columns.find((x) => x.isPrimaryId)?.apiPropertyName;
    if (!targetTablePrimaryIdColumnLogicalName) {
        return undefined;
    }

    const targetTablePrimaryNameColumnLogicalName = getPrimaryNameColumn(targetTableMetadata).apiPropertyName;
    if (!targetTablePrimaryNameColumnLogicalName) {
        return undefined;
    }

    return {
        [targetTablePrimaryIdColumnLogicalName]: row[`_${column.apiPropertyName}_value`],
        [targetTablePrimaryNameColumnLogicalName]: row[`_${column.apiPropertyName}_value@OData.Community.Display.V1.FormattedValue`],
    };
}

export async function formatAsDataverseLookup(
    tableMetadata: TableToTypescriptMapping,
    column: LookupColumnToTypescriptMapping,
    rowData: NotNullOrUndefinedTableCell,
): Promise<string | undefined> {
    const anyRowData = rowData as Record<string, string>;

    const idProp = column.lookupMetadata.targetTableApiMetadataTableId + 'id';
    if (!anyRowData?.[idProp]) {
        return undefined;
    }

    const rowId = anyRowData[idProp];

    // GUID validation regex - matches standard GUID format
    const guidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;

    if (!guidRegex.test(rowId)) {
        logWarning('formatAsDataverseLookup', {
            type: 'InvalidGuidFormat',
            data: {
                ...getTableAndColumnEventData(tableMetadata, column),
                rowId
            }
        });
        return undefined;
    }

    const targetTableMetadata = await getTableMetadata({ apiMetadataTableId: column.lookupMetadata.targetTableApiMetadataTableId });

    return `/${targetTableMetadata.apiDataTableId}(${rowId})`;
}

export function formatChoicesAsStringArray(
    tableMetadata: TableToTypescriptMapping,
    column: ChoiceColumnToTypescriptMapping,
    tableCell: NotNullOrUndefinedTableCell
): TableCell {
    if (typeof tableCell !== 'string') {
        logWarning('formatChoicesAsStringArray', {
            type: 'InvalidChoiceValueType',
            data: getTableAndColumnEventData(tableMetadata, column)
        });
        return tableCell;
    }

    return tableCell.split(',').map((item) => item.trim());
}

export function formatChoicesAsCommaSeparatedString(
    tableMetadata: TableToTypescriptMapping,
    column: ChoiceColumnToTypescriptMapping,
    tableCell: NotNullOrUndefinedTableCell
): string | undefined | null {
    // Handle array input (most common case for multi-select)
    if (Array.isArray(tableCell)) {
        const results: number[] = [];
        const unmappedChoiceValues: string[] = [];

        for (const item of tableCell) {
            if (item === null || item === undefined) {
                continue;
            }

            const itemAsString = typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean'
                ? String(item)
                : String(item);
            const lowercaseItem = itemAsString.toLowerCase().trim();
            const option = column.optionSetMetadata.options.find((x) => {
                return (
                    x.label.toLowerCase().trim() === lowercaseItem
                    || x.apiValue.toString().toLowerCase().trim() === lowercaseItem
                );
            });

            if (option) {
                results.push(option.apiValue as number);
            } else {
                unmappedChoiceValues.push(lowercaseItem);
            }
        }
        if (unmappedChoiceValues.length > 0) {
            logWarning('formatChoicesAsCommaSeparatedString', {
                type: 'UnmappedChoicesValues',
                data: {
                    ...getTableAndColumnEventData(tableMetadata, column),
                    unmappedChoiceValues: unmappedChoiceValues.join(',')
                }
            });
        }

        return results.length > 0 ? results.join(',') : null;
    } else {
        logWarning('formatChoicesAsCommaSeparatedString', {
            type: 'InvalidChoiceValueType',
            data: getTableAndColumnEventData(tableMetadata, column)
        });
    }

    return undefined;
}

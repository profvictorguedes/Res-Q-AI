/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 * This file is autogenerated. Do not edit this file directly.
 */

import { v4 as uuid } from 'uuid';

import { type IOperationResult } from '@microsoft/power-apps/data';
import { type DataClient } from '@microsoft/power-apps/data';
import { initialize as byocSdkClientInitialize } from '@microsoft/power-apps/app';
import { getCommonDataSourceOperations } from './common/common-data-source-operations-client';
import type { ScenarioContext } from './common/logger-client';
import { logInfo, withScenarioLogging } from './common/logger-client';
import type { TableToTypescriptMapping } from './common/table-mapping-types';
import { getDataModelConfigForLog, getPrimaryNameColumn, getTableMetadata } from './common/table-metadata-utils';
import type { IOperationOptions, TableRow } from './common/types';

byocSdkClientInitialize();

function makeOperationResult<T>(data: T, error?: unknown): IOperationResult<T> {
    return {
        success: !error,
        data,
        error: (error as Error)
    };
}

function addTableMetadataToScenarioContext(
    baseContext: ScenarioContext,
    tableMetadata: TableToTypescriptMapping,
): void {
    baseContext.dataSourceType = tableMetadata.dataSourceType;
}

export class AppGenDataClient {
    public constructor() {
        logInfo('AppGenDataClient/Initialized', getDataModelConfigForLog());
    }

    public async createRecordAsync(dataSourceName: string, record: TableRow): Promise<IOperationResult<TableRow>> {
        const baseContext: ScenarioContext = {
            dataSourceName,
            typescriptPropertyNames: Object.keys(record)
        };

        return withScenarioLogging('createRecordAsync', baseContext, async () => {
            if (!dataSourceName) {
                throw new Error('dataSourceName is required');
            }
            if (!record) {
                throw new Error('record is required');
            }

            const tableMetadata = await getTableMetadata({ dataSourceName });
            addTableMetadataToScenarioContext(baseContext, tableMetadata);

            const dataSourceOpClient = getCommonDataSourceOperations(tableMetadata);

            await dataSourceOpClient.throwIfInputRecordIsInvalid(tableMetadata, record);

            const primaryColumn = getPrimaryNameColumn(tableMetadata);
            if (record[primaryColumn.typescriptPropertyName] === undefined || record[primaryColumn.typescriptPropertyName] === null) {
                throw new Error(`Primary name column '${primaryColumn.typescriptPropertyName}', for dataSourceName: ${dataSourceName} must have a value.`);
            }

            let newRowId = record.id as string || uuid();
            if (record.id && typeof record.id === 'string') {
                newRowId = record.id;
            }

            record = await dataSourceOpClient.mapTypescriptRowToDataSourceRow(tableMetadata, record);
            record = await dataSourceOpClient.mapDataSourceRowToApiRow(tableMetadata, record, newRowId);

            await dataSourceOpClient.getDataClient().createRecordAsync(tableMetadata, record);

            record = await dataSourceOpClient.mapApiRowToDataSourceRow(tableMetadata, record);
            record = await dataSourceOpClient.mapDataSourceRowToTypescriptRow(tableMetadata, record);

            return makeOperationResult(record);
        });
    }

    public async updateRecordAsync(dataSourceName: string, recordId: string, recordChanges: TableRow): Promise<IOperationResult<TableRow>> {
        const baseContext: ScenarioContext = {
            dataSourceName,
            recordId,
            typescriptPropertyNames: Object.keys(recordChanges)
        };

        return withScenarioLogging('updateRecordAsync', baseContext, async () => {
            if (!dataSourceName) {
                throw new Error('dataSourceName is required');
            }

            if (!recordChanges) {
                throw new Error('recordChanges are required');
            }

            if (!recordId) {
                throw new Error('recordId is required');
            }

            const tableMetadata = await getTableMetadata({ dataSourceName });
            addTableMetadataToScenarioContext(baseContext, tableMetadata);

            const dataSourceOpClient = getCommonDataSourceOperations(tableMetadata);

            await dataSourceOpClient.throwIfInputRecordIsInvalid(tableMetadata, recordChanges);

            let currentApiRow = await dataSourceOpClient.getDataClient().retrieveRecordAsync(tableMetadata, recordId);

            currentApiRow = JSON.parse(JSON.stringify(currentApiRow)) as TableRow;

            const newDataSourceChanges = await dataSourceOpClient.mapTypescriptRowToDataSourceRow(tableMetadata, recordChanges);
            const newApiChanges = await dataSourceOpClient.mapDataSourceRowToApiRow(tableMetadata, newDataSourceChanges, recordId);

            let rowToSendToApi = newApiChanges;
            if (dataSourceOpClient.getDataClient().requiresFullRowForUpdate()) {
                rowToSendToApi = { ...currentApiRow, ...rowToSendToApi } as TableRow;
            }

            await dataSourceOpClient.getDataClient().updateRecordAsync(tableMetadata, rowToSendToApi, recordId);

            if (!dataSourceOpClient.getDataClient().requiresFullRowForUpdate()) {
                rowToSendToApi = { ...currentApiRow, ...newApiChanges } as TableRow;
            }

            const resultDataSourceRow = await dataSourceOpClient.mapApiRowToDataSourceRow(tableMetadata, rowToSendToApi);
            const resultTypescriptRow = await dataSourceOpClient.mapDataSourceRowToTypescriptRow(tableMetadata, resultDataSourceRow);

            return makeOperationResult(resultTypescriptRow);
        });
    }

    public async deleteRecordAsync(dataSourceName: string, recordId: string): Promise<IOperationResult<void>> {
        const baseContext: ScenarioContext = {
            dataSourceName,
            recordId,
        };

        return withScenarioLogging('deleteRecordAsync', baseContext, async () => {
            if (!dataSourceName) {
                throw new Error('dataSourceName is required');
            }

            const tableMetadata = await getTableMetadata({ dataSourceName });
            addTableMetadataToScenarioContext(baseContext, tableMetadata);

            const dataSourceOpClient = getCommonDataSourceOperations(tableMetadata);

            await dataSourceOpClient.getDataClient().deleteRecordAsync(tableMetadata, recordId);

            return makeOperationResult<void>(undefined);
        });
    }

    public async retrieveRecordAsync(dataSourceName: string, recordId: string): Promise<IOperationResult<TableRow>> {
        const baseContext: ScenarioContext = {
            dataSourceName,
            recordId,
        };

        return withScenarioLogging('retrieveRecordAsync', baseContext, async () => {
            if (!dataSourceName) {
                throw new Error('dataSourceName is required');
            }

            const tableMetadata = await getTableMetadata({ dataSourceName });
            addTableMetadataToScenarioContext(baseContext, tableMetadata);

            const dataSourceOpClient = getCommonDataSourceOperations(tableMetadata);

            const row = await dataSourceOpClient.getDataClient().retrieveRecordAsync(tableMetadata, recordId);

            const dataSourceResult = await dataSourceOpClient.mapApiRowToDataSourceRow(tableMetadata, row);
            const typescriptResult = await dataSourceOpClient.mapDataSourceRowToTypescriptRow(tableMetadata, dataSourceResult);

            return makeOperationResult(typescriptResult);
        });
    }

    public async retrieveMultipleRecordsAsync(dataSourceName: string, options?: IOperationOptions): Promise<IOperationResult<TableRow[]>> {
        const baseContext: ScenarioContext = {
            dataSourceName,
            orderBy: options?.orderBy,
            hasFilter: !!options?.filter,
        };

        return withScenarioLogging('retrieveMultipleRecordsAsync', baseContext, async () => {
            if (!dataSourceName) {
                throw new Error('dataSourceName is required');
            }

            const tableMetadata = await getTableMetadata({ dataSourceName });
            addTableMetadataToScenarioContext(baseContext, tableMetadata);

            const dataSourceOpClient = getCommonDataSourceOperations(tableMetadata);

            await dataSourceOpClient.throwIfInputOptionsIsInvalid(tableMetadata, options);

            if (options) {
                options = await dataSourceOpClient.convertOptionsToDataSourceSchema(tableMetadata, options);
            }

            const rows = await dataSourceOpClient.getDataClient().retrieveMultipleRecordsAsync(tableMetadata, options);

            const result: TableRow[] = [];
            for (const row of rows) {
                const formatted = await dataSourceOpClient.mapApiRowToDataSourceRow(tableMetadata, row);
                const typescriptRow = await dataSourceOpClient.mapDataSourceRowToTypescriptRow(tableMetadata, formatted);
                result.push(typescriptRow);
            }

            baseContext.resultCount = result.length;

            return makeOperationResult(result);
        });
    }
}

let appGenDataClient: DataClient;
export function getClient(): Omit<DataClient, 'executeAsync'> {
    if (!appGenDataClient) {
        appGenDataClient = (new AppGenDataClient()) as DataClient;
    }

    return appGenDataClient;
}
